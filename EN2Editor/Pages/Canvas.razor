@using EN2Editor.Model.Selection
@using EN2Editor.Model
@using Nodes
@using EN2Editor.Model
@using EN2Editor.Model.Selection
@using System.Reflection.Metadata
@using System.Drawing
@using Rectangle = Models.Rectangle

@inject SelectionManager selectionManager
@inject NodeModelManager nodeModelManager
@inject IJSRuntime jsRuntime

<div class="diagram-container">
    <div id="CanvasID" class="diagram-canvas"
         @onmousemove="OnMouseMove"
         @onmouseup="OnMouseUp"
         @onmousedown="OnMouseDownCanvas"
         ondragover="event.preventDefault()"
         @ondrop="OnDrop"
         @ref=canvasElement>
        <svg class="diagram-svg-layer" style="z-index: 1000">
            @foreach (LinkModel link in nodeModelManager.Links) {
                <Link LinkModel="link"/>
            }
        </svg>
        <div class="diagram-html-layer">
            @foreach (NodeModelBase node in nodeModelManager.Nodes) {
                <NodeFactory NodeModelBase="@node" OnDeleteEvent="OnDeleteNode"/>
            }
        </div>

    </div>

</div>

@code {


    protected override async Task OnInitializedAsync() { }
    ElementReference canvasElement;

    private void OnMouseDownCanvas(MouseEventArgs e) { }


    // This method must be in this component, because it is the canvas, which must re-render itself upon node removal.
    private void OnDeleteNode(NodeModelBase node) {
        nodeModelManager.DeleteNode(node);
        StateHasChanged();
    }

    private async Task OnDrop(MouseEventArgs e) {
        Console.WriteLine("Dropped");
        if (selectionManager.IsDraggingToolbarNode) {
            Rectangle rect = await jsRuntime.InvokeAsync<Rectangle>("helpers.getBoundingClientRectangle", "CanvasID");

            nodeModelManager.Nodes.Add(new NodeModelBase {
                X = e.ClientX - (int) rect.Left - 100, //rectangle[0], // TODO get width for node and -width/2
                Y = e.ClientY - (int) rect.Top - 20, //rectangle[1],
                NodeType = selectionManager.NodeTypeInCreation
            });
            selectionManager.IsDraggingToolbarNode = false;
            StateHasChanged();
        }
    }

    private void OnMouseMove(MouseEventArgs e) {
        NodeModelBase node = selectionManager.GrabbedNode;
        LinkModel link = selectionManager.DraggedLink;
        if (node != null) {
            double deltaX = (e.ClientX - selectionManager.LastX);
            double deltaY = (e.ClientY - selectionManager.LastY);
            node.X = deltaX + selectionManager.InitialX;
            node.Y = deltaY + selectionManager.InitialY;
        } else if (link != null) {
            double deltaX = (e.ClientX - selectionManager.LastX);
            double deltaY = (e.ClientY - selectionManager.LastY);
            link.EndX = (int) (deltaX + selectionManager.InitialX);
            link.EndY = (int) (deltaY + selectionManager.InitialY);

    // Console.WriteLine("Dragging curve");
        }
    }

    // private async void DrawLine() {
    //     await jsRuntime.InvokeVoidAsync("helpers.drawBezier",
    //         "TransitionCanvas",
    //         selectionManager.InitialX, // start
    //         selectionManager.InitialY,
    //         transitionX, // end
    //         transitionY
    //         );
    // }

    private void OnMouseUp(MouseEventArgs e) {
        if (selectionManager.DraggedLink != null) {
            nodeModelManager.Links.Remove(selectionManager.DraggedLink);
        }
        selectionManager.GrabbedNode = null;
        selectionManager.DraggedLink = null;
    }

}